<!DOCTYPE html>
<html lang="en">
<head>
    <meta content="application/xhtml+xml; charset=utf-8" http-equiv="content-type">
    <title>Docker workshop</title>

    <link href="dist/reset.css" rel="stylesheet"/>
    <link href="dist/reveal.css" rel="stylesheet"/>
    <link href="dist/theme/black.css" rel="stylesheet">

    <link href="plugin/highlight/monokai.css" rel="stylesheet">
    <link href="files/customstyle.css" rel="stylesheet">
</head>
<body>
<p class="presentationlink">
    <a href="https://github.com/CapNK20/dockerworkshop">https://github.com/CapNK20/dockerworkshop</a>
</p>
<div class="reveal">
    <div class="slides">
        <section>Docker for tinkerers</section>

        <section>
            <section>
                <h1>Prerequisites</h1>
                <ul>
                    <li>Something that can build docker images</li>
                    <li>Something that can run docker images</li>
                    <li>Something that can run docker compose files</li>
                    <li>Something that can edit files</li>
                    <li>A command line</li>
                    <li>A browser</li>
                </ul>
            </section>

            <section>
                <h1>Please be a little more specific!!</h1>
            </section>

            <section>
                <h1>Recommended on windows:</h1>
                <ul>
                    <li>Docker desktop, running using WSL2</li>
                    <li>A Jetbrains IDE or Visual Studio Code</li>
                    <li>Chrome or Firefox</li>
                    <li>bash inside WSL, or powershell</li>
                </ul>
            </section>

            <section>
                <h1>Recommended on mac:</h1>

                <p>TODO</p>

                <ul>
                    <li>Docker desktop?</li>
                    <li>A Jetbrains IDE or Visual Studio Code?</li>
                    <li>Chrome or Firefox or Safari?</li>
                    <li>bash? something else?</li>
                </ul>
            </section>

            <section>
                <h1>What if I don't have docker?</h1>

                <ul>
                    <li><p>Play with docker</p>
                        <ul>
                            <li>Gives you a free temporary playground. You just need a docker account</li>
                            <li><a href="https://labs.play-with-docker.com/">https://labs.play-with-docker.com</a></li>
                        </ul>
                    </li>
                    <li>Azure</li>
                    <li>Aws</li>
                    <li>Google cloud</li>
                </ul>
                <aside class="notes">
                    Play with docker and the cloud services can be used in the browser, but it's probably better with an
                    ssh client
                    or other
                    method
                </aside>
            </section>

        </section>
        <section>
            <h1>Navigating the presentation</h1>
            <ul>
                <li>`Space` for next slide</li>
                <li>Arrow keys to navigate slides</li>
                <li>`O` or `Esc` to open the overview</li>
                <li>`S` to open the speaker notes</li>
            </ul>
        </section>

        <section>
            <section>
                <h1>Multi stage builds</h1>
                <p>Getting a final image without all the intermediate build layers</p>
            </section>

            <section>
                <h1>Why?</h1>
                <ul>
                    <li>Keep things only needed for building out of the final image</li>
                    <li>Separation of concerns</li>
                    <li>Optimize build</li>
                </ul>
                <aside class="notes">
                    <p>Keeping things out of the final image has two advantages. 1: The less that is there the less
                        tools an attacker has to work with. 2: Making the final running image smaller can save some
                        resources</p>
                    <p>Build can also be faster because if there are multiple stages buildkit may run them in parallell
                        if resources and dependencies between the projects permit</p>
                </aside>
            </section>

            <section>
                <h1>How?</h1>
                <pre><code class="language-dockerfile" data-trim>
                    FROM sdk AS builder
                    COPY source .
                    RUN build.sh

                    FROM gen AS datagenerator
                    COPY data-source .
                    RUN generate.sh

                    FROM runtime
                    COPY --from=builder build-result/mycmd .
                    COPY --from=datagenerator data data
                    ENTRYPOINT ["mycmd"]
                </code></pre>
                <aside class="notes">
                    Here the builder and the datagenerator don't depend on each other so they could end up being run in
                    parallell. The final image depends on both of them so will be build last.
                </aside>
            </section>
        </section>

        <section>
            <section>
                <h1>Using build time arguments</h1>
                <p>Lets us give arguements to the build, so we could build different images from the same dockerfile and
                    source. Or provide values that aren't known when making the Dockerfile
            </section>

            <section>
                <h1>Exercise</h1>
                <p><code>challenge/buildargs</code></p>
                <p>Change the dockerfile so that it can take a version as a build argument and compile that into the
                    executable in the docker image. You shouldn't need to change anything in the project code</p>
                <p><a href="https://docs.docker.com/reference/dockerfile/#arg">https://docs.docker.com/reference/dockerfile/#arg</a>
                </p>
                <pre><code class="language-bash" data-trim>
                    $ docker build -t tmp .
                    $ docker run tmp
                    $ docker build -t tmp --build-arg version=1.2.3.4 .
                    $ docker run tmp
                </code></pre>
            </section>
        </section>

        <section>
            <section>
                <h1>Starting from a clean slate</h1>

                <p>Using <code>FROM scratch</code></p>

                <aside class="notes">

                    You don have to start from a base image. If you start from the special keyword `scratch` you will
                    get an image with only
                    the files you add to it, no operating system or anything. That's only useful if you don't need them
                    but can give really
                    tiny images.
                </aside>
            </section>

            <section>
            <pre><code class="language-dockerfile" data-trim>
                FROM foo AS build
                WORKDIR build
                COPY . .
                RUN buid_static_executable

                FROM scratch
                COPY --from=build /build/output/static_executable \
                  /bin/static_executable
                ENTRYPOINT ["/bin/static_executable"]
            </code></pre>
            </section>

            <section>
                <code>examples/scratch</code>
                <pre><code class="language-bash" data-trim>
                    $ docker build -t tiny
                    $ docker run --rm tiny
                    Hello, world!
                </code></pre>
                <p>Pull down some common base images and compare sizes</p>
                <pre><code class="language-bash" data-trim>
                    $ docker pull ubuntu
                    $ docker pul alpine
                    $ docker image ls --filter=reference=ubuntu \
                        --filter=reference=alpine --filter=reference=tiny
                </code></pre>
            </section>
        </section>

        <section>
            <section>
                <h1>Juggling versions</h1>
                <p>Dealing with multiple projects needing different versions of dependencies, by doing the development
                    work
                    inside docker</p>
                <p>Good IDEs have build in support using built in using standardized dev containers</p>
                <ul>
                    <li><a href="https://containers.dev/">https://containers.dev/</a></li>
                    <li><a href="https://code.visualstudio.com/docs/devcontainers/containers">https://code.visualstudio.com/docs/devcontainers/containers</a>
                    </li>
                    <li><a href="https://www.jetbrains.com/help/idea/connect-to-devcontainer.html">https://www.jetbrains.com/help/idea/connect-to-devcontainer.html</a>
                    </li>
                </ul>
                <aside class="notes">
                    <p>No, Visual Studio is currently not a good IDE, because it doesn't have dev container support. <i>qed</i>
                    </p>
                </aside>
            </section>

            <section>
                <p><code>examples/devcontainers</code></p>
                <p>Visual studio code:</p>
                <p>Make sure dev containers extension is installed. Open folder, popup asks if you want to open in dev
                    container. Confirm</p>
                <br/>
                <p>Intellij family of IDEs:</p>
                <p>Make sure dev container plugin is installed and enabled. Either choose devcontainer from the initial
                    "Open project" window. Or open the folder and right click on the devcontainers json</p>
            </section>

            <section>
                <h1>Exercise</h1>
                <ol>
                    <li>Make a devcontainer for a project you're working on</li>
                    <li>Find a github project that you don have the tools for installed on your machine. Make a
                        devcontainer for it
                    </li>
                </ol>
            </section>
        </section>

        <section>
            <section>
                <h1>Using a proxy</h1>
                <p>... to serve everything from the same "domain"</p>
                <p>Because CORS is a pain, and handling cookies when testing locally is only going to get worse once
                    chrome starts blocking all third party cookies by default</p>
            </section>
            <section>
                <h1>Exercise</h1>
                <p><code>challenge/proxy</code></p>
                <p>Run the docker compose file and open <a href="http://localhost/swagger">http://localhost/swagger</a>
                    in your favorite browser and try out the api.
                </p>
                <p>
                    There is a second swagger file but no service to implement it. Create one using your favorite
                    framework or copy from foo service.
                </p>
            </section>
        </section>

        <section>
            <section>
                <h1>Watching files with docker compose</h1>
                <ul>
                    <li>Use watch function in language/runtime to refresh when there are changes that can be hot
                        reloaded
                    </li>
                    <li>Use watch in docker compose to restart when there are changes that need the services to be
                        restarted
                    </li>
                    <li>Use watch in docker compose to rebuild images when there are changes that require a new image
                    </li>
                </ul>
            </section>

            <section>
                <code>examples/scratch</code>
                <pre><code class="language-bash" data-trim>
                    $ docker compose watch
                </code></pre>
                <p>What happens when you:</p>
                <ul>
                    <li>Make a change to <code>frontend/index.html</code>?</li>
                    <li>Run <code>npm install so that</code> so that the package lock file changes?</li>
                    <li>Change <code>launchSettings.json</code>?</li>
                    <li>Add something to one of the dockerfiles?</li>
                </ul>
            </section>
        </section>

        <section>
            <section>
                <h1>Divide and conquer</h1>
                <h2> with <code>include</code> and <code>extends</code></h2>
                <p>Include and extends allow reuse between multiple docker compose files</p>
                <aside class="notes">
                    <p>sooner or later you you'll end up using docker for multiple things. perhaps sometimes run the
                        frontend and backend locally, but using an external database instead of a local one. or maybe
                        sometimes configured for extra logging. Eventually editing the docker compose for specific
                        scenarios, and remembering to undo before committing, becomes a pain in the &#x1facf;. At this
                        point it≈õ logical to start introducing different compose files for different purposes, and you
                        will soon run into the problem of having duplicates and keeping them in sync. That's when being
                        able to split a compose file into reusable parts becomes useful</p>
                </aside>
            </section>

            <section>
                <h2>Short syntax</h2>
                <pre><code class="language-yaml" data-trim>
                    include:
                      - file1.yaml
                      - file2.yaml
                </code></pre>
                <h2>Long syntax</h2>
                <pre><code class="language-yaml" data-trim>
                    include:
                      - path: file1.yaml
                        project_directory: ./some/where
                        env_file: file1.env
                      - path: file2.yaml
                </code></pre>
                <aside class="notes">
                    <p>project_directory is optional and sets where to resolve relative paths in the file. It defaults
                        to the folder of the file</p>
                    <p>env_file is optional and is used to override values for variables in the imported compose file.
                        Defaults to .env in project_directory</p>
                </aside>
            </section>

            <section>
                <h2>Use multiple paths to merge definitions</h2>
                <pre><code class="language-yaml" data-trim>
                    include:
                      - path:
                          - file1.yaml
                          - file2.yaml
                        project_directory: ./some/where
                        env_file: file1.env
                </code></pre>
                <aside class="notes">
                    <p>If two files in separate includes specify the same service name they will conflict and docker
                        compose will refuse</p>
                    <p>To have yaml files merged specify two or more in a single include (requires long syntax)</p>
                </aside>
            </section>

            <section>
                <h1>Using extends</h1>
                <p>TODO example</p>
            </section>
        </section>

        <section>
            <section>
                <h1>Using the syntax directive</h1>
                <p>To get new or experimental features</p>
            </section>

            <section>
                <pre><code class="language-dockerfile" data-trim># syntax=docker/dockerfile:1</code></pre>
                <p>Will get you the latest stable version 1</p>
                <aside class="notes">
                    <p>If you don't specify anything you will get whatever shipped with your docker installation, which
                        may be out of date</p>
                </aside>
            </section>

            <section>
                <pre><code class="language-dockerfile" data-trim># syntax=docker/dockerfile:labs</code></pre>
                <p>Gets you the latest experimental release</p>
                <pre><code class="language-dockerfile" data-trim># syntax=docker/dockerfile-upstream:master-labs</code></pre>
                <p>Uses latest prerelease version. Be prepared for things to break</p>
                <aside class="notes">
                    <p><code>docker/dockerfile:1</code> refers to a dockerfile frontend, an image that can read a file
                        and output LLB instructions that buildkit understands and turns into a new image. There is also
                        a bunch of alternate frontends that reads formats that may or may not look like dockerfiles.M
                    </p>
                    <ul>
                        <li>Mockerfile. a yaml syntax for specifing a build. Because apparently some people like yaml
                        </li>
                        <li>one that can read a rust project file with a little extra metadata, and create an optimized
                            parallel image build for it
                        </li>
                        <li>Mopy. Another yaml syntax. This one specifically for building python based images</li>
                    </ul>
                </aside>
            </section>
        </section>

        <section>
            <section>
                <h1>Principle of least privilege</h1>
                <p>Running without admin rights</p>
                <aside class="notes">
                    <p>Combine with using multi stage build to create an image with as few extras as possible. Leaving
                        an attacker as little to work with as possible</p>
                </aside>
            </section>

            <section>
                <pre><code class="language-dockerfile" data-trim>
                    FROM sdk AS builder
                    COPY source .
                    RUN build

                    FROM tiny-runtime
                    COPY --from=builder --chmod=555 executable .
                    # Add user if not provided by image
                    RUN useradd --no-create-home --shell /bin/false --user-group app
                    USER app:app
                    ENTRYPOINT ["executable"]
                </code></pre>
                <aside class="notes">
                    <p>Useradd command creates a user without a home folder, and with /bin/false as the shell. Leaving
                        it as few privileges as possible</p>
                    <p>Command to create user differs between base images. You need to check the docs</p>
                    <p>We do the copying and stuff before the <code>USER</code> statement. Because the runtime user
                        won't have the permissions to create those files</p>
                    <p>You may need to give the user permissions for </p>
                </aside>
            </section>
        </section>

        <section>
            <section>
                <h1>Check image security with docker scout</h1>
                <p>Local analysis is included for free with docker desktop</p>
            </section>

            <section>
                <p>TODO example by running devcontainer from earlier. Grabbing the image is and scanning that. Should
                    get some hits because of old node</p>
            </section>

        </section>

        <section>
            <section>
                <h1>What to do next. Links and stuff</h1>
                <p>TODO</p>
            </section>

            <section>
                <h1>Swarm</h1>
                <p>Quickest way to try out running with multiple instances and load balancing locally</p>
            </section>

            <section>
                <h1>Kubernetes</h1>
                <p>If your production environment is running on kubernetes you should probably skip swarm and go
                    straight here</p>
                <h2>What is kubernetes</h2>
                <p>TODO</p>
            </section>
        </section>
    </div>
</div>

<script src="dist/reveal.js"></script>
<script src="plugin/notes/notes.js"></script>
<script src="plugin/markdown/markdown.js"></script>
<script src="plugin/highlight/highlight.js"></script>
<script src="plugin/zoom/zoom.js"></script>
<script>
    Reveal.initialize({
        width: 1600,
        height: 1200,
        margin: 0.04,
        hash: true,
        plugins: [
            RevealMarkdown,
            RevealHighlight,
            RevealNotes,
            RevealZoom
        ]
        // ,slideNumber: true
    });
</script>
</body>
</html>
